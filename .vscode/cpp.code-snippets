{
	"C++ Base Setup": {
		"prefix": "cppsetup",
		"body": [
			"#include<bits/stdc++.h>",
			"using namespace std;",
			"class Solution{",
			"",
			"};",
			"",
			"int main(){",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"    Solution solution;",	
			"",
			"    return 0;",
			"}"
		],
		"description": "Basic C++ template with Solution class and fast IO"
	},

	"Disjoint Set Union (DSU)": {
		"prefix": "disjoint set dsu",
		"body": [
			"class disjointSet {",
			"    vector<int> rank, parent, size;",
			"public:",
			"    disjointSet(int n) {",
			"        rank.resize(n+1, 0);",
			"        size.resize(n+1, 1);",
			"        parent.resize(n+1);",
			"        for(int i = 0; i < n; i++) parent[i] = i;",
			"    }",
			"",
			"    int findUParent(int node) {",
			"        if (node == parent[node]) return node;",
			"        return parent[node] = findUParent(parent[node]);",
			"    }",
			"",
			"    void unionByRank(int u, int v) {",
			"        int ulp_u = findUParent(u);",
			"        int ulp_v = findUParent(v);",
			"        if (ulp_u == ulp_v) return;",
			"        if (rank[ulp_u] < rank[ulp_v]) {",
			"            parent[ulp_u] = ulp_v;",
			"        } else if (rank[ulp_v] < rank[ulp_u]) {",
			"            parent[ulp_v] = ulp_u;",
			"        } else {",
			"            parent[ulp_v] = ulp_u;",
			"            rank[ulp_u]++;",
			"        }",
			"    }",
			"",
			"    void unionBySize(int u, int v) {",
			"        int ulp_u = findUParent(u);",
			"        int ulp_v = findUParent(v);",
			"        if (ulp_u == ulp_v) return;",
			"        if (size[ulp_u] < size[ulp_v]) {",
			"            parent[ulp_u] = ulp_v;",
			"            size[ulp_v] += size[ulp_u];",
			"        } else {",
			"            parent[ulp_v] = ulp_u;",
			"            size[ulp_u] += size[ulp_v];",
			"        }",
			"    }",
			"};"
		],
		"description": "Disjoint Set Union (Union by Rank / Size with Path Compression)"
	},
	"Insert BLACKBOX Graph-BFS Code": {
		"prefix": "blackbox",
		"body": [
			"//****************BLACKBOX START*****************",
			"//START COPYING FROM HERE",
			"",
			"typedef int ll;",
			"",
			"class Hash {",
			"  private:",
			"  \tmap<tuple<int,int,int>,int>hash_table;",
			"  public:",
			"  \tHash () {}",
			"  \tint hash(int x){",
			"  \t\treturn hash({x,0,0});",
			"  \t}",
			"  \tint hash(tuple<int,int>x){",
			"  \t\treturn hash({get<0>(x),get<1>(x),0});",
			"  \t}",
			"  \tint hash(tuple<int,int,int>x){",
			"  \t\tif(hash_table.find(x)!=hash_table.end())",
			"  \t\t\treturn hash_table[x];",
			"  \t\tint new_hash = hash_table.size();",
			"  \t\thash_table[x]=new_hash;",
			"  \t\treturn new_hash;",
			"  \t}",
			"};",
			"",
			"class Graph {",
			"",
			"  \tbool is_directed;",
			"",
			"  \tpublic:",
			"  \t\tvector<vector<pair<int,ll>>>adj;",
			"    \tint n,N=5000000;",
			"    \tHash h;",
			"",
			"  \t\tGraph(int n_, bool is_directed_ = true){",
			"  \t\t\tn=n_; is_directed = is_directed_;",
			"  \t\t\tadj.resize(N,vector<pair<int,ll>>());",
			"  \t\t}",
			"",
			"  \t\tint hash(int u, int v){",
			"  \t\t\treturn h.hash({u,v});",
			"  \t\t}",
			"  \t\tint hash(int u, int v, int k){",
			"  \t\t\treturn h.hash({u,v,k});",
			"  \t\t}",
			"",
			"  \t\tvoid add_edge(int uR, int vR, ll c=0){",
			"  \t\t  int u=h.hash(uR), v=h.hash(vR);",
			"  \t\t  add_edge_internal(u,v,c);",
			"  \t\t}",
			"  \t\tvoid add_edge(tuple<int,int> uR, tuple<int,int> vR, ll c=0){",
			"  \t\t  int u=h.hash(uR), v=h.hash(vR);",
			"  \t\t  add_edge_internal(u,v,c);",
			"  \t\t}",
			"  \t\tvoid add_edge(tuple<int,int,int> uR, tuple<int,int,int> vR, ll c=0){",
			"  \t\t  int u=h.hash(uR), v=h.hash(vR);",
			"  \t\t  add_edge_internal(u,v,c);",
			"  \t\t}",
			"",
			"",
			"  \tprivate :",
			"",
			"  \t  void add_edge_internal(int u, int v, ll c=0){",
			"  \t\t\tadd_edge_weighted_undirected(u,v,c);",
			"  \t\t\tif(!is_directed)",
			"  \t\t\t\tadd_edge_weighted_undirected(v,u,c);",
			"  \t\t}",
			"  \t\tvoid add_edge_weighted_undirected(int u, int v, ll c) {",
			"  \t\t\tpair<int,ll>p = make_pair(v,c);",
			"  \t\t\tadj[u].push_back(p);",
			"  \t\t}",
			"",
			"};",
			"",
			"class BFS {",
			"    vector<ll>min_dist_from_source;",
			"    vector<bool> visited;",
			"    Graph *g;",
			"",
			"    public:",
			"      BFS(Graph *g_) {",
			"          g = g_;",
			"          clear();",
			"      }",
			"",
			"  \t\tvoid clear() {",
			"  \t\t\tmin_dist_from_source.clear();",
			"  \t\t\tmin_dist_from_source.resize(g->N,-1);",
			"  \t\t\tvisited.clear();",
			"  \t\t\tvisited.resize(g->N, false);",
			"  \t\t}",
			"",
			"      void run(int sourceR) {",
			"        int source = (g->h).hash(sourceR);",
			"        run_internal(source);",
			"      }",
			"      void run(tuple<int,int> sourceR) {",
			"        int source = (g->h).hash(sourceR);",
			"        run_internal(source);",
			"      }",
			"      void run(tuple<int,int,int> sourceR) {",
			"        int source = (g->h).hash(sourceR);",
			"        run_internal(source);",
			"      }",
			"",
			"      int min_dist(int targetR){",
			"      \tint target = (g->h).hash(targetR);",
			"      \treturn min_dist_internal(target);",
			"      }",
			"      int min_dist(tuple<int,int> targetR){",
			"      \tint target = (g->h).hash(targetR);",
			"      \treturn min_dist_internal(target);",
			"      }",
			"      int min_dist(tuple<int,int,int> targetR){",
			"      \tint target = (g->h).hash(targetR);",
			"      \treturn min_dist_internal(target);",
			"      }",
			"",
			"      bool is_visited(int targetR){",
			"      \tint target = (g->h).hash(targetR);",
			"      \treturn is_visited_internal(target);",
			"      }",
			"      bool is_visited(tuple<int,int> targetR){",
			"      \tint target = (g->h).hash(targetR);",
			"      \treturn is_visited_internal(target);",
			"      }",
			"      bool is_visited(tuple<int,int,int> targetR){",
			"      \tint target = (g->h).hash(targetR);",
			"      \treturn is_visited_internal(target);",
			"      }",
			"",
			"  private:",
			"    void run_internal(int source) {",
			"  \t\tqueue<int> q;",
			"  \t\tq.push(source);",
			"",
			"  \t\tvisited[source] = true;",
			"  \t\tmin_dist_from_source[source] = 0;",
			"",
			"  \t\twhile(!q.empty()) {",
			"  \t\t\tint cur_node = q.front();",
			"  \t\t\tfor (unsigned int i = 0; i < (g->adj[cur_node]).size(); ++i) {",
			"  \t\t\t\tint adj_node =  (g->adj[cur_node])[i].first;",
			"  \t\t\t\tif (visited[adj_node] == false) {",
			"  \t\t\t\t\tvisited[adj_node] = true;",
			"  \t\t\t\t\tmin_dist_from_source[adj_node] = min_dist_from_source[cur_node] + 1;",
			"  \t\t\t\t\tq.push(adj_node);",
			"  \t\t\t\t}",
			"  \t\t\t}",
			"  \t\t\tq.pop();",
			"  \t\t}",
			"",
			"  \t\treturn;",
			"    }",
			"",
			"    int min_dist_internal(int target){",
			"    \treturn min_dist_from_source[target];",
			"    }",
			"",
			"    bool is_visited_internal(int target){",
			"    \treturn visited[target];",
			"    }",
			"",
			"};",
			"//END COPYING HERE",
			"//********************BLACKBOX END******************"
			],
			"description": "Insert the BLACKBOX hash-based graph + BFS structure"
		},
		"TreeNode Class": {
			"prefix": "treenode",
			"body": [
				"class TreeNode {",
				"public:",
				"    int val;",
				"    TreeNode *left;",
				"    TreeNode *right;",
				"",
				"    TreeNode(int val1) {",
				"        val = val1;",
				"        left = nullptr;",
				"        right = nullptr;",
				"    }",
				"",
				"    TreeNode(int val1, TreeNode *left1, TreeNode *right1) {",
				"        val = val1;",
				"        left = left1;",
				"        right = right1;",
				"    }",
				"};"
			],
			"description": "TreeNode class definition with constructors"
		},
		"Trie and Node structure": {
		"prefix": "trieclass",
		"body": [
			"struct Node {",
			"    Node * links[26];",
			"    bool flag = false;",
			"",
			"    bool containsKey(char ch) {",
			"        return (links[ch - 'a'] != NULL);",
			"    }",
			"",
			"    void put(char ch, Node * node) {",
			"        links[ch - 'a'] = node;",
			"    }",
			"",
			"    Node * get(char ch) {",
			"        return links[ch - 'a'];",
			"    }",
			"",
			"    void setEnd() {",
			"        flag = true;",
			"    }",
			"",
			"    bool isEnd() {",
			"        return flag;",
			"    }",
			"};",
			"",
			"class Trie {",
			"private:",
			"    Node * root;",
			"public:",
			"    Trie() {",
			"        root = new Node();",
			"    }",
			"",
			"    void insert(string word) {",
			"        Node * node = root;",
			"        for (int i = 0; i < word.length(); i++) {",
			"            if (!node->containsKey(word[i])) {",
			"                node->put(word[i], new Node());",
			"            }",
			"            node = node->get(word[i]);",
			"        }",
			"        node->setEnd();",
			"    }",
			"",
			"    bool search(string word) {",
			"        Node * node = root;",
			"        for (int i = 0; i < word.length(); i++) {",
			"            if (!node->containsKey(word[i])) {",
			"                return false;",
			"            }",
			"            node = node->get(word[i]);",
			"        }",
			"        return node->isEnd();",
			"    }",
			"",
			"    bool startsWith(string prefix) {",
			"        Node * node = root;",
			"        for (int i = 0; i < prefix.length(); i++) {",
			"            if (!node->containsKey(prefix[i])) {",
			"                return false;",
			"            }",
			"            node = node->get(prefix[i]);",
			"        }",
			"        return true;",
			"    }",
			"};"
		],
		"description": "C++ Trie and Node implementation"
		}



}
	

